<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π –¥–Ω–µ–≤–Ω–∏–∫</title>
    <link rel="icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b1220;
            --panel: #f8fafc;
            --panel-strong: #ffffff;
            --ink: #0f172a;
            --muted: #475569;
            --accent: #f97316;
            --accent-2: #0ea5e9;
            --ring: rgba(14, 165, 233, 0.25);
            --shadow: 0 20px 50px rgba(15, 23, 42, 0.18);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: "Manrope", sans-serif;
            background: radial-gradient(1200px 500px at 10% -10%, #1f2937 0%, transparent 60%),
                        radial-gradient(800px 400px at 90% 0%, #0f766e 0%, transparent 55%),
                        linear-gradient(180deg, #0b1220 0%, #111827 100%);
            min-height: 100vh;
            color: var(--ink);
            padding: 24px 16px 80px;
        }

        .app {
            max-width: 1040px;
            margin: 0 auto;
        }

        .header {
            color: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 18px;
            gap: 12px;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            object-fit: cover;
            background: #ffffff;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .auth-panel {
            background: rgba(248, 250, 252, 0.1);
            border-radius: 14px;
            padding: 10px 12px;
            display: grid;
            gap: 8px;
            color: #e2e8f0;
            margin-bottom: 16px;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #e2e8f0;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .auth-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .auth-row .input {
            background: #ffffff;
        }

        .auth-status {
            font-size: 12px;
            color: #cbd5f5;
        }

        .export-btn {
            border: 0;
            background: rgba(248, 250, 252, 0.1);
            color: #e2e8f0;
            width: 44px;
            height: 44px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 18px;
            display: grid;
            place-items: center;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .export-btn:hover {
            background: rgba(248, 250, 252, 0.2);
            transform: translateY(-1px);
        }

        .header-title {
            font-size: 26px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }

        .header-subtitle {
            font-size: 14px;
            color: #94a3b8;
        }

        .tabs {
            display: flex;
            gap: 10px;
            background: rgba(15, 23, 42, 0.5);
            padding: 8px;
            border-radius: 16px;
            margin-bottom: 18px;
            backdrop-filter: blur(10px);
        }

        .tab-btn {
            flex: 1;
            border: 0;
            background: transparent;
            color: #cbd5f5;
            font-weight: 600;
            padding: 12px 14px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn.active {
            background: #f8fafc;
            color: #0f172a;
            box-shadow: 0 10px 20px rgba(15, 23, 42, 0.15);
        }

        .panel {
            background: var(--panel);
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .calendar-title {
            font-weight: 700;
            font-size: 18px;
        }

        .icon-btn {
            border: 0;
            background: #e2e8f0;
            color: #0f172a;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }

        .calendar-weekday {
            text-align: center;
            font-size: 12px;
            font-weight: 700;
            color: var(--muted);
            text-transform: uppercase;
        }

        .day-btn {
            border: 1px solid transparent;
            background: var(--panel-strong);
            border-radius: 12px;
            padding: 10px;
            min-height: 52px;
            cursor: pointer;
            position: relative;
            font-weight: 600;
        }

        .day-btn.has-workout::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 8px;
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.18);
        }

        .day-btn.active {
            border-color: var(--accent-2);
            box-shadow: 0 0 0 3px var(--ring);
        }

        .day-btn.today {
            border-color: rgba(249, 115, 22, 0.5);
            background: rgba(249, 115, 22, 0.1);
        }

        .workout-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .duration {
            background: rgba(14, 165, 233, 0.15);
            padding: 8px 12px;
            border-radius: 12px;
            font-weight: 700;
            color: #0f172a;
        }

        .status-badge {
            background: rgba(34, 197, 94, 0.15);
            color: #166534;
            padding: 6px 10px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 12px;
        }

        .workout-date {
            font-size: 18px;
            font-weight: 700;
        }

        .tonnage {
            background: #e2e8f0;
            padding: 8px 12px;
            border-radius: 12px;
            font-weight: 700;
        }

        .catalog-panel {
            background: #ffffff;
            border-radius: 18px;
            border: 1px solid #e2e8f0;
            padding: 16px;
            margin-bottom: 18px;
        }

        .catalog-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 12px;
        }

        .catalog-title {
            font-weight: 700;
            font-size: 16px;
        }

        .group-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .group-btn {
            border: 0;
            padding: 8px 14px;
            border-radius: 999px;
            background: #e2e8f0;
            font-weight: 600;
            cursor: pointer;
        }

        .group-btn.active {
            background: var(--accent-2);
            color: #fff;
        }

        .catalog-controls {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            margin-bottom: 12px;
        }

        .catalog-select {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }

        .catalog-select.selected {
            border-color: var(--accent-2);
            box-shadow: 0 0 0 3px var(--ring);
            background: #ecfeff;
        }

        .catalog-list {
            display: grid;
            gap: 8px;
        }

        .catalog-item {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
            background: #f8fafc;
            border-radius: 12px;
            padding: 10px 12px;
        }

        .catalog-item.selected {
            background: rgba(14, 165, 233, 0.15);
            border: 1px solid rgba(14, 165, 233, 0.4);
        }

        .catalog-pick {
            border: 0;
            background: transparent;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
        }

        .catalog-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .icon-action {
            border: 1px solid #e2e8f0;
            background: transparent;
            padding: 6px 8px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            line-height: 1;
        }

        .icon-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .select-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .input, select {
            width: 100%;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid #cbd5f5;
            font-size: 15px;
            font-family: inherit;
            background: #fff;
        }

        .btn {
            border: 0;
            padding: 12px 16px;
            border-radius: 12px;
            background: var(--accent);
            color: #fff;
            font-weight: 700;
            cursor: pointer;
        }

        .btn.secondary {
            background: #0f172a;
        }

        .ghost-btn {
            border: 1px solid #e2e8f0;
            background: transparent;
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #0f172a;
        }

        .ghost-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .entries-title {
            font-weight: 700;
            margin-bottom: 12px;
        }

        .entry-card {
            background: #ffffff;
            border-radius: 16px;
            padding: 16px;
            border: 1px solid #e2e8f0;
            margin-bottom: 14px;
        }

        .entry-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }

        .entry-title {
            font-weight: 700;
            font-size: 16px;
        }

        .entry-group {
            font-size: 12px;
            background: #e2e8f0;
            padding: 4px 8px;
            border-radius: 999px;
            margin-left: 8px;
        }

        .entry-prev {
            margin-top: 6px;
            color: var(--muted);
            font-size: 13px;
        }

        .set-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px dashed #e2e8f0;
            font-size: 14px;
        }

        .set-row:last-child {
            border-bottom: none;
        }

        .set-form {
            display: grid;
            grid-template-columns: repeat(3, 1fr) auto auto;
            gap: 8px;
            margin-top: 12px;
        }

        .manual-row {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .manual-row.hidden {
            display: none;
        }

        .timer-card {
            background: #0f172a;
            color: #e2e8f0;
            border-radius: 16px;
            padding: 16px;
            display: grid;
            gap: 10px;
        }

        .timer-display {
            font-size: 32px;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .timer-bar {
            height: 8px;
            background: rgba(226, 232, 240, 0.2);
            border-radius: 999px;
            overflow: hidden;
        }

        .timer-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f97316, #0ea5e9);
            transition: width 0.2s ease;
        }

        .timer-bar-fill.expired {
            background: linear-gradient(90deg, #ef4444, #f97316);
        }

        .mood-block {
            display: grid;
            gap: 8px;
            margin-bottom: 14px;
        }

        .mood-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: #ffffff;
            border-radius: 14px;
            padding: 12px 14px;
            border: 1px solid #e2e8f0;
        }

        .mood-label {
            font-weight: 600;
        }

        .stars {
            display: flex;
            gap: 6px;
        }

        .star {
            font-size: 20px;
            cursor: pointer;
            color: #cbd5f5;
            transition: transform 0.2s ease, color 0.2s ease;
        }

        .star.active {
            color: #facc15;
            transform: scale(1.05);
        }

        .timer-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .chart-card {
            background: #ffffff;
            border-radius: 16px;
            padding: 16px;
            border: 1px solid #e2e8f0;
        }

        .empty {
            color: var(--muted);
            font-style: italic;
            padding: 16px 0;
        }

        @media (max-width: 720px) {
            body {
                padding-bottom: 120px;
            }

            .tabs {
                position: fixed;
                bottom: 12px;
                left: 12px;
                right: 12px;
                margin-bottom: 0;
                z-index: 5;
                box-shadow: 0 16px 30px rgba(15, 23, 42, 0.3);
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .catalog-controls {
                grid-template-columns: 1fr;
            }

            .group-buttons {
                width: 100%;
            }

            .set-form {
                grid-template-columns: 1fr 1fr;
            }

            .set-form .btn,
            .set-form .ghost-btn {
                grid-column: span 2;
            }

            .manual-row {
                grid-template-columns: 1fr;
            }

            .timer-controls {
                flex-direction: column;
            }

            .catalog-actions {
                width: 100%;
            }

            .auth-row {
                flex-direction: column;
                align-items: stretch;
            }

            .logo {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-brand">
                <img class="logo" src="logo.png" alt="–õ–æ–≥–æ—Ç–∏–ø">
                <div>
                    <div class="header-title">üèãÔ∏è –¢—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π –¥–Ω–µ–≤–Ω–∏–∫</div>
                    <div class="header-subtitle">–ö–∞–ª–µ–Ω–¥–∞—Ä—å, –ø–æ–¥—Ö–æ–¥—ã, —Ç–∞–π–º–µ—Ä –æ—Ç–¥—ã—Ö–∞ –∏ –≥—Ä–∞—Ñ–∏–∫–∏</div>
                </div>
            </div>
            <div class="header-actions">
                <button class="export-btn" type="button" data-action="export-data" aria-label="–í—ã–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ" title="–í—ã–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ">‚§ì</button>
            </div>
        </header>

        <div class="sync-status" id="syncStatus">‚ö†Ô∏è –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞</div>

        <div class="auth-panel" id="authPanel">
            <div class="auth-row">
                <input class="input" type="email" id="authEmail" placeholder="Email –¥–ª—è –≤—Ö–æ–¥–∞">
                <input class="input" type="password" id="authPassword" placeholder="–ü–∞—Ä–æ–ª—å">
                <button class="btn" type="button" data-action="auth-signin">–í–æ–π—Ç–∏</button>
                <button class="ghost-btn" type="button" data-action="auth-signup">–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç</button>
                <button class="ghost-btn" type="button" data-action="auth-login">–í–æ–π—Ç–∏ –ø–æ —Å—Å—ã–ª–∫–µ</button>
                <button class="ghost-btn" type="button" data-action="auth-logout">–í—ã–π—Ç–∏</button>
            </div>
            <div class="auth-status" id="authStatus">–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞</div>
        </div>

        <div class="tabs" id="tabs">
            <button class="tab-btn active" data-tab="calendar">–ö–∞–ª–µ–Ω–¥–∞—Ä—å</button>
            <button class="tab-btn" data-tab="workout">–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞</button>
            <button class="tab-btn" data-tab="charts">–ì—Ä–∞—Ñ–∏–∫–∏</button>
        </div>

        <section class="tab-panel active" id="tab-calendar">
            <div class="panel">
                <div class="calendar-header">
                    <button class="icon-btn" data-action="prev-month">‚Üê</button>
                    <div class="calendar-title" id="calendarTitle"></div>
                    <button class="icon-btn" data-action="next-month">‚Üí</button>
                </div>
                <div class="calendar-grid" id="calendarWeekdays"></div>
                <div class="calendar-grid" id="calendarGrid"></div>
            </div>
        </section>

        <section class="tab-panel" id="tab-workout">
            <div class="panel">
                <div class="workout-header">
                    <div class="workout-date" id="selectedDateLabel"></div>
                    <div class="duration">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <span id="durationValue">00:00:00</span></div>
                    <div class="tonnage">–¢–æ–Ω–Ω–∞–∂: <span id="tonnageValue">0</span> –∫–≥</div>
                    <div id="workoutStatus"></div>
                    <button class="ghost-btn" type="button" data-action="finish-workout">–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É</button>
                </div>

                <div class="mood-block" id="moodBlock"></div>

                <div class="catalog-panel" id="catalogPanel"></div>
            </div>

            <div class="panel">
                <div class="entries-title">–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∑–∞ –¥–µ–Ω—å (–≤ –ø–æ—Ä—è–¥–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è)</div>
                <div id="entriesList"></div>
            </div>

            <div class="panel">
                <div class="timer-card">
                    <div>–¢–∞–π–º–µ—Ä –æ—Ç–¥—ã—Ö–∞</div>
                    <div class="timer-display" id="timerDisplay">00:00</div>
                    <div class="timer-bar"><div class="timer-bar-fill" id="timerBar"></div></div>
                    <div id="timerStatus">–ì–æ—Ç–æ–≤ –∫ —Å—Ç–∞—Ä—Ç—É</div>
                    <div class="timer-controls">
                        <button class="btn" data-action="timer-start">–°—Ç–∞—Ä—Ç</button>
                        <button class="btn secondary" data-action="timer-pause">–ü–∞—É–∑–∞</button>
                        <button class="ghost-btn" data-action="timer-reset">–°–±—Ä–æ—Å</button>
                    </div>
                </div>
            </div>
        </section>

        <section class="tab-panel" id="tab-charts">
            <div class="panel">
                <div class="form-row">
                    <select id="exerciseSelect"></select>
                    <button class="btn" type="button" data-action="refresh-charts">–û–±–Ω–æ–≤–∏—Ç—å</button>
                </div>
                <div class="form-row">
                    <select id="chartTypeSelect"></select>
                    <select id="periodSelect"></select>
                </div>
                <div class="form-row" id="customRange">
                    <input class="input" type="date" id="fromDate">
                    <input class="input" type="date" id="toDate">
                </div>
                <div class="chart-card">
                    <canvas id="exerciseChart" height="220"></canvas>
                    <div class="empty" id="chartEmpty">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—é.</div>
                </div>
            </div>
        </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const GROUPS = ["–ì—Ä—É–¥—å", "–°–ø–∏–Ω–∞", "–†—É–∫–∏", "–ù–æ–≥–∏", "–ü–ª–µ—á–∏", "–ü—Ä–µ—Å—Å"];
        const STORAGE_KEY = "workoutDataV3";
        const SUPABASE_URL = "https://dwgdefrmmykfzsvtcsjh.supabase.co";
        const SUPABASE_ANON_KEY = "sb_publishable_TAsCglmNK5MKehKbkS8gwg_b2uZK8ug";

        const state = {
            data: loadData(),
            selectedDateKey: toDateKey(new Date()),
            currentMonth: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
            activeTab: "calendar",
            restTimer: { remaining: 0, total: 0, intervalId: null, running: false },
            chart: null,
            selectedExercise: "",
            selectedCatalogGroup: GROUPS[0],
            selectedCatalogExercise: {},
            chartType: "max",
            period: "all",
            customFrom: "",
            customTo: "",
            editingSet: null,
            user: null,
            supabase: null,
            syncing: false,
            remoteCache: { workouts: {}, catalogs: {} }
        };

        const WEIGHT_OPTIONS = buildWeightOptions();
        const REP_OPTIONS = buildRepOptions();
        const CHART_TYPES = [
            { value: "max", label: "–ú–∞–∫—Å. –≤–µ—Å" },
            { value: "tonnage", label: "–¢–æ–Ω–Ω–∞–∂" },
            { value: "avgWeight", label: "–°—Ä–µ–¥–Ω–∏–π –≤–µ—Å" },
            { value: "avgReps", label: "–°—Ä–µ–¥–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—ã" },
            { value: "sets", label: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥—Ö–æ–¥–æ–≤" },
            { value: "oneRm", label: "1RM (Epley)" },
            { value: "topSet", label: "–¢–æ–ø-—Å–µ—Ç (–≤–µ—Å√ó–ø–æ–≤—Ç–æ—Ä—ã)" }
        ];
        const PERIOD_OPTIONS = [
            { value: "all", label: "–° –Ω–∞—á–∞–ª–∞" },
            { value: "7", label: "–ü–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π" },
            { value: "30", label: "–ü–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π" },
            { value: "90", label: "–ü–æ—Å–ª–µ–¥–Ω–∏–µ 90 –¥–Ω–µ–π" },
            { value: "custom", label: "–°–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω" }
        ];
        const DEFAULT_CATALOG = {
            "–ì—Ä—É–¥—å": [
                "–ë—Ä—É—Å—å—è",
                "–û—Ç–∂–∏–º–∞–Ω–∏—è",
                "–ñ–∏–º –ª–µ–∂–∞",
                "–†–∞–∑–≤–æ–¥–∫–∞ –≥–∞–Ω—Ç–µ–ª–µ–π –Ω–∞ —Å–∫–∞–º—å–µ",
                "–ö—Ä–æ—Å—Å–æ–≤–µ—Ä (–≤–µ—Ä—Ö–Ω–µ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ)",
                "–ö—Ä–æ—Å—Å–æ–≤–µ—Ä (–Ω–∏–∂–Ω–µ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ)"
            ],
            "–°–ø–∏–Ω–∞": [
                "–ë—Ä—É—Å—å—è",
                "–û—Ç–∂–∏–º–∞–Ω–∏—è",
                "–¢—è–≥–∞ —à—Ç–∞–Ω–≥–∏ –∫ –ø–æ—è—Å—É",
                "–¢—è–≥–∞ –≥–∞–Ω—Ç–µ–ª–∏ –Ω–∞ —Å–∫–∞–º—å–µ",
                "–ö—Ä–æ—Å—Å–æ–≤–µ—Ä (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π)",
                "–ö—Ä–æ—Å—Å–æ–≤–µ—Ä (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π)"
            ],
            "–†—É–∫–∏": [
                "–ë–∏—Ü–µ–ø—Å ‚Äî –≥–∞–Ω—Ç–µ–ª–∏ –∫ –ø–ª–µ—á—É",
                "–ë–∏—Ü–µ–ø—Å ‚Äî —Ö–∞–º–µ—Ä",
                "–¢—Ä–∏—Ü–µ–ø—Å ‚Äî –∫—Ä–æ—Å—Å–æ–≤–µ—Ä"
            ],
            "–ù–æ–≥–∏": [
                "–ü—Ä–∏—Å–µ–¥ —Å–æ —à—Ç–∞–Ω–≥–æ–π",
                "–ë–æ–ª–≥–∞—Ä—Å–∫–∞—è —Ç—è–≥–∞ –Ω–∞ –¥–≤—É—Ö",
                "–ë–æ–ª–≥–∞—Ä—Å–∫–∞—è —Ç—è–≥–∞ –Ω–∞ –æ–¥–Ω–æ–π",
                "–ö–æ–ª–µ–Ω–æ –∑–∞ –Ω–æ—Å–æ–∫",
                "–í—ã–ø–∞–¥—ã"
            ],
            "–ü–ª–µ—á–∏": [
                "–ü–ª–µ—á–∏ ‚Äî —Ç—è–≥–∞ —à—Ç–∞–Ω–≥–∏",
                "–†–∞–∑–≤–æ–¥–∫–∞",
                "–ö—Ä–æ—Å—Å–æ–≤–µ—Ä"
            ],
            "–ü—Ä–µ—Å—Å": ["–ö–∞—á–∞—Ç—å"]
        };

        let durationIntervalId = null;

        const calendarTitle = document.getElementById("calendarTitle");
        const calendarWeekdays = document.getElementById("calendarWeekdays");
        const calendarGrid = document.getElementById("calendarGrid");
        const selectedDateLabel = document.getElementById("selectedDateLabel");
        const catalogPanel = document.getElementById("catalogPanel");
        const entriesList = document.getElementById("entriesList");
        const tonnageValue = document.getElementById("tonnageValue");
        const durationValue = document.getElementById("durationValue");
        const workoutStatus = document.getElementById("workoutStatus");
        const moodBlock = document.getElementById("moodBlock");
        const timerDisplay = document.getElementById("timerDisplay");
        const timerStatus = document.getElementById("timerStatus");
        const timerBar = document.getElementById("timerBar");
        const exerciseSelect = document.getElementById("exerciseSelect");
        const chartTypeSelect = document.getElementById("chartTypeSelect");
        const periodSelect = document.getElementById("periodSelect");
        const customRange = document.getElementById("customRange");
        const fromDate = document.getElementById("fromDate");
        const toDate = document.getElementById("toDate");
        const chartEmpty = document.getElementById("chartEmpty");
        const authPanel = document.getElementById("authPanel");
        const authEmail = document.getElementById("authEmail");
        const authPassword = document.getElementById("authPassword");
        const authStatus = document.getElementById("authStatus");
        const syncStatus = document.getElementById("syncStatus");

        initSupabase();
        renderAll();
        setupEventListeners();

        function setupEventListeners() {
            document.getElementById("tabs").addEventListener("click", (event) => {
                const button = event.target.closest(".tab-btn");
                if (!button) return;
                setActiveTab(button.dataset.tab);
            });

            document.addEventListener("click", (event) => {
                const button = event.target.closest("[data-action]");
                if (!button) return;
                const action = button.dataset.action;
                if (action === "prev-month") changeMonth(-1);
                if (action === "next-month") changeMonth(1);
                if (action === "timer-start") startTimer();
                if (action === "timer-pause") pauseTimer();
                if (action === "timer-reset") resetTimer();
                if (action === "refresh-charts") renderCharts();
                if (action === "delete-entry") deleteEntry(button.dataset.id);
                if (action === "delete-set") deleteSet(button.dataset.entryId, button.dataset.setId);
                if (action === "edit-set") setEditingSet(button.dataset.entryId, button.dataset.setId);
                if (action === "cancel-edit") clearEditingSet();
                if (action === "save-set") saveEditedSet(button.dataset.entryId, button.dataset.setId, button);
                if (action === "delete-catalog") deleteCatalog(button.dataset.group, decodeName(button.dataset.name));
                if (action === "rename-catalog") renameCatalogPrompt(button.dataset.group, decodeName(button.dataset.name));
                if (action === "add-entry") addEntryFromCatalog(button.dataset.group);
                if (action === "plus-rest") incrementRest(button.dataset.entryId);
                if (action === "toggle-manual") toggleManualInput(button.dataset.entryId);
                if (action === "repeat-plus") addRepeatPlus(button.dataset.entryId);
                if (action === "export-data") exportData();
                if (action === "select-group") selectCatalogGroup(button.dataset.group);
                if (action === "show-chart") showChartForExercise(decodeName(button.dataset.name));
                if (action === "add-catalog") addCatalogFromPanel();
                if (action === "rename-selected") renameSelectedExercise(button.dataset.group);
                if (action === "delete-selected") deleteSelectedExercise(button.dataset.group);
                if (action === "finish-workout") finishWorkout();
                if (action === "auth-login") sendMagicLink();
                if (action === "auth-logout") signOut();
                if (action === "auth-signin") signInWithPassword();
                if (action === "auth-signup") signUpWithPassword();
            });

            calendarGrid.addEventListener("click", (event) => {
                const dayBtn = event.target.closest("[data-date]");
                if (!dayBtn) return;
                state.selectedDateKey = dayBtn.dataset.date;
                renderCalendar();
                renderWorkout();
                setActiveTab("workout");
            });


            entriesList.addEventListener("submit", (event) => {
                const form = event.target.closest(".set-form");
                if (!form) return;
                event.preventDefault();
                const entryId = form.dataset.entryId;
                const weightManual = parseFloat(form.querySelector("[name=weightManual]").value);
                const repsManual = parseInt(form.querySelector("[name=repsManual]").value, 10);
                const weightSelect = parseFloat(form.querySelector("[name=weightSelect]").value);
                const repsSelect = parseInt(form.querySelector("[name=repsSelect]").value, 10);
                const weight = Number.isFinite(weightManual) ? weightManual : weightSelect;
                const reps = Number.isFinite(repsManual) ? repsManual : repsSelect;
                const restMin = parseInt(form.querySelector("[name=restMin]").value, 10) || 0;
                if (!Number.isFinite(weight) || !Number.isFinite(reps)) return;
                addSet(entryId, weight, reps, restMin);
                form.reset();
                const manualRow = form.querySelector(".manual-row");
                const toggleBtn = form.querySelector("[data-action=toggle-manual]");
                if (manualRow) manualRow.classList.add("hidden");
                if (toggleBtn) toggleBtn.textContent = "–†—É—á–Ω–æ–π –≤–≤–æ–¥";
            });

            moodBlock.addEventListener("click", (event) => {
                const star = event.target.closest("[data-mood]");
                if (!star) return;
                const type = star.dataset.type;
                const rating = parseInt(star.dataset.mood, 10);
                if (!Number.isFinite(rating)) return;
                setMood(type, rating);
            });

            exerciseSelect.addEventListener("change", () => {
                state.selectedExercise = decodeName(exerciseSelect.value);
                renderCharts();
            });

            chartTypeSelect.addEventListener("change", () => {
                state.chartType = chartTypeSelect.value;
                renderCharts();
            });

            periodSelect.addEventListener("change", () => {
                state.period = periodSelect.value;
                renderCharts();
            });

            fromDate.addEventListener("change", () => {
                state.customFrom = fromDate.value;
                renderCharts();
            });

            toDate.addEventListener("change", () => {
                state.customTo = toDate.value;
                renderCharts();
            });

            catalogPanel.addEventListener("change", (event) => {
                const select = event.target.closest("[data-catalog-select]");
                if (!select) return;
                const name = decodeName(select.value || "");
                if (name) {
                    selectCatalogExercise(state.selectedCatalogGroup, name);
                }
            });
        }

        function setActiveTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.classList.toggle("active", btn.dataset.tab === tab);
            });
            document.querySelectorAll(".tab-panel").forEach(panel => {
                panel.classList.toggle("active", panel.id === `tab-${tab}`);
            });
            if (tab === "charts") renderCharts();
        }

        function renderAll() {
            renderCalendar();
            renderWorkout();
            renderCharts();
        }

        function renderCalendar() {
            const monthLabel = state.currentMonth.toLocaleDateString("ru-RU", { month: "long", year: "numeric" });
            calendarTitle.textContent = capitalizeFirst(monthLabel);
            const todayKey = toDateKey(new Date());

            calendarWeekdays.innerHTML = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
                .map(day => `<div class="calendar-weekday">${day}</div>`)
                .join("");

            const firstDay = new Date(state.currentMonth.getFullYear(), state.currentMonth.getMonth(), 1);
            const daysInMonth = new Date(state.currentMonth.getFullYear(), state.currentMonth.getMonth() + 1, 0).getDate();
            const startOffset = (firstDay.getDay() + 6) % 7;

            const cells = [];
            for (let i = 0; i < startOffset; i += 1) {
                cells.push(`<div></div>`);
            }

            for (let day = 1; day <= daysInMonth; day += 1) {
                const dateKey = toDateKey(new Date(state.currentMonth.getFullYear(), state.currentMonth.getMonth(), day));
                const isActive = dateKey === state.selectedDateKey;
                const hasWorkout = workoutHasData(dateKey);
                const isToday = dateKey === todayKey;
                cells.push(`
                    <button class="day-btn ${isActive ? "active" : ""} ${hasWorkout ? "has-workout" : ""} ${isToday ? "today" : ""}" data-date="${dateKey}">
                        ${day}
                    </button>
                `);
            }

            calendarGrid.innerHTML = cells.join("");
        }

        function renderWorkout() {
            ensureWorkout(state.selectedDateKey);
            selectedDateLabel.textContent = formatDate(state.selectedDateKey);
            tonnageValue.textContent = formatNumber(calculateTonnage(state.selectedDateKey));
            renderDuration();

            const workout = state.data.workoutsByDate[state.selectedDateKey];
            moodBlock.innerHTML = `
                <div class="mood-row">
                    <div class="mood-label">–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏</div>
                    <div class="stars">${renderStars("before", workout.moodBefore)}</div>
                </div>
                <div class="mood-row">
                    <div class="mood-label">–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏</div>
                    <div class="stars">${renderStars("after", workout.moodAfter)}</div>
                </div>
            `;

            const isFinished = Boolean(workout.finishedAt);
            workoutStatus.innerHTML = isFinished ? `<span class="status-badge">–ó–∞–≤–µ—Ä—à–µ–Ω–∞</span>` : "";
            const finishBtn = document.querySelector("[data-action=finish-workout]");
            if (finishBtn) finishBtn.disabled = isFinished;

            renderCatalogPanel();
            if (!workout.entries.length) {
                entriesList.innerHTML = `<div class="empty">–ü–æ–∫–∞ –Ω–µ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –∑–∞ —ç—Ç—É –¥–∞—Ç—É.</div>`;
                return;
            }

            entriesList.innerHTML = workout.entries.map(entry => {
                const setsHtml = entry.sets.map((set, index) => {
                const restText = set.restSec ? formatDuration(set.restSec) : "‚Äî";
                    const isEditing = state.editingSet && state.editingSet.entryId === entry.id && state.editingSet.setId === set.id;
                    return `
                        <div class="set-row">
                            <div>
                                #${index + 1} ¬∑ ${isEditing ? `
                                    <input class=\"input\" type=\"number\" step=\"0.5\" min=\"0\" value=\"${set.weight}\" data-edit-weight>
                                    <input class=\"input\" type=\"number\" min=\"1\" value=\"${set.reps}\" data-edit-reps>
                                ` : `${set.weight} –∫–≥ √ó ${set.reps} –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π`} ¬∑ –æ—Ç–¥—ã—Ö ${restText}
                            </div>
                            <div class="catalog-actions">
                                ${isEditing ? `
                                    <button class=\"icon-action\" data-action=\"save-set\" data-entry-id=\"${entry.id}\" data-set-id=\"${set.id}\" aria-label=\"–°–æ—Ö—Ä–∞–Ω–∏—Ç—å\" title=\"–°–æ—Ö—Ä–∞–Ω–∏—Ç—å\">‚úî</button>
                                    <button class=\"icon-action\" data-action=\"cancel-edit\" aria-label=\"–û—Ç–º–µ–Ω–∞\" title=\"–û—Ç–º–µ–Ω–∞\">‚úñ</button>
                                ` : `
                                    <button class=\"icon-action\" data-action=\"edit-set\" data-entry-id=\"${entry.id}\" data-set-id=\"${set.id}\" aria-label=\"–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å\" title=\"–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å\">‚úèÔ∏è</button>
                                    <button class=\"icon-action\" data-action=\"delete-set\" data-entry-id=\"${entry.id}\" data-set-id=\"${set.id}\" aria-label=\"–£–¥–∞–ª–∏—Ç—å\" title=\"–£–¥–∞–ª–∏—Ç—å\">üóë</button>
                                `}
                            </div>
                        </div>
                    `;
                }).join("");

                return `
                    <div class="entry-card">
                        <div class="entry-header">
                            <div>
                                <div class="entry-title">${escapeHtml(entry.name)}<span class="entry-group">${escapeHtml(entry.group)}</span></div>
                                ${renderPreviousSet(entry.name)}
                            </div>
                            <div class="catalog-actions">
                                <button class="ghost-btn" data-action="show-chart" data-name="${encodeName(entry.name)}">–ì—Ä–∞—Ñ–∏–∫</button>
                                <button class="ghost-btn" data-action="delete-entry" data-id="${entry.id}">–£–¥–∞–ª–∏—Ç—å</button>
                            </div>
                        </div>
                        ${setsHtml || "<div class=\"empty\">–ü–æ–¥—Ö–æ–¥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.</div>"}
                        <form class="set-form" data-entry-id="${entry.id}">
                            <select class="input" name="weightSelect" required>
                                ${WEIGHT_OPTIONS}
                            </select>
                            <select class="input" name="repsSelect" required>
                                ${REP_OPTIONS}
                            </select>
                            <input class="input" name="restMin" type="number" min="0" placeholder="–û—Ç–¥—ã—Ö, –º–∏–Ω">
                            <button class="ghost-btn" type="button" data-action="plus-rest" data-entry-id="${entry.id}">+1 –º–∏–Ω</button>
                            <button class="ghost-btn" type="button" data-action="toggle-manual" data-entry-id="${entry.id}">–†—É—á–Ω–æ–π –≤–≤–æ–¥</button>
                            <button class="ghost-btn" type="button" data-action="repeat-plus" data-entry-id="${entry.id}" ${entry.sets.length ? "" : "disabled"}>–ü–æ–≤—Ç–æ—Ä–∏—Ç—å +1</button>
                            <button class="btn" type="submit">–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥—Ö–æ–¥</button>
                            <div class="manual-row hidden">
                                <input class="input" name="weightManual" type="number" min="0" step="0.5" placeholder="–í–µ—Å –≤—Ä—É—á–Ω—É—é, –∫–≥">
                                <input class="input" name="repsManual" type="number" min="1" placeholder="–ü–æ–≤—Ç–æ—Ä—ã –≤—Ä—É—á–Ω—É—é">
                            </div>
                        </form>
                    </div>
                `;
            }).join("");
        }

        function renderStars(type, current) {
            return [1, 2, 3, 4, 5].map(value => `
                <span class="star ${value <= current ? "active" : ""}" data-mood="${value}" data-type="${type}">‚òÖ</span>
            `).join("");
        }

        function renderPreviousSet(name) {
            const previous = findPreviousSet(name, state.selectedDateKey);
            if (!previous) return "";
            return `<div class="entry-prev">–ü—Ä–æ—à–ª—ã–π —Ä–∞–∑: ${previous.weight} –∫–≥ √ó ${previous.reps}</div>`;
        }

        function setMood(type, rating) {
            const workout = ensureWorkout(state.selectedDateKey);
            if (type === "before") workout.moodBefore = rating;
            if (type === "after") workout.moodAfter = rating;
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
        }

        function renderCatalogPanel() {
            const group = state.selectedCatalogGroup;
            const catalog = state.data.catalogByGroup[group] || [];
            if (!state.selectedCatalogExercise[group] && catalog.length) {
                state.selectedCatalogExercise[group] = catalog[0];
            }
            const selected = state.selectedCatalogExercise[group] || "";
            catalogPanel.innerHTML = `
                <div class="catalog-header">
                    <div class="catalog-title">–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π</div>
                    <div class="group-buttons">
                        ${GROUPS.map(item => `
                            <button class="group-btn ${item === group ? "active" : ""}" data-action="select-group" data-group="${item}">${item}</button>
                        `).join("")}
                    </div>
                </div>
                <div class="catalog-controls">
                    <input class="input" type="text" placeholder="–ù–æ–≤–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ" data-catalog-new>
                    <button class="btn" type="button" data-action="add-catalog">–î–æ–±–∞–≤–∏—Ç—å</button>
                </div>
                    <div class="form-row">
                        <select class="input catalog-select ${selected ? "selected" : ""}" data-catalog-select>
                            ${catalog.length ? catalog.map(name => `
                                <option value="${encodeName(name)}" ${name === selected ? "selected" : ""}>${escapeHtml(name)}</option>
                            `).join("") : `<option value="">–ù–µ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π</option>`}
                        </select>
                        <div class="select-actions">
                            <button class="icon-action" type="button" data-action="rename-selected" data-group="${group}" aria-label="–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å" title="–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å" ${selected ? "" : "disabled"}>‚úèÔ∏è</button>
                            <button class="icon-action" type="button" data-action="delete-selected" data-group="${group}" aria-label="–£–¥–∞–ª–∏—Ç—å" title="–£–¥–∞–ª–∏—Ç—å" ${selected ? "" : "disabled"}>üóë</button>
                            <button class="btn secondary" type="button" data-action="add-entry" data-group="${group}">–î–æ–±–∞–≤–∏—Ç—å –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É</button>
                        </div>
                    </div>
            `;
        }

        function renderCharts() {
            const names = collectExerciseNames();
            exerciseSelect.innerHTML = names.length
                ? names.map(name => `<option value="${encodeName(name)}">${escapeHtml(name)}</option>`).join("")
                : `<option value="">–ù–µ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π</option>`;

            if (!state.selectedExercise || !names.includes(state.selectedExercise)) {
                state.selectedExercise = names[0] || "";
            }

            exerciseSelect.value = encodeName(state.selectedExercise);
            if (!state.selectedExercise) {
                chartEmpty.style.display = "block";
                destroyChart();
                return;
            }

            chartTypeSelect.innerHTML = CHART_TYPES.map(type => `
                <option value="${type.value}">${type.label}</option>
            `).join("");
            if (!CHART_TYPES.find(type => type.value === state.chartType)) {
                state.chartType = CHART_TYPES[0].value;
            }
            chartTypeSelect.value = state.chartType;

            periodSelect.innerHTML = PERIOD_OPTIONS.map(option => `
                <option value="${option.value}">${option.label}</option>
            `).join("");
            if (!PERIOD_OPTIONS.find(option => option.value === state.period)) {
                state.period = PERIOD_OPTIONS[0].value;
            }
            periodSelect.value = state.period;
            customRange.style.display = state.period === "custom" ? "grid" : "none";
            if (!fromDate.value && state.customFrom) fromDate.value = state.customFrom;
            if (!toDate.value && state.customTo) toDate.value = state.customTo;

            const filteredDates = getFilteredDates(Object.keys(state.data.workoutsByDate).sort());
            const stats = buildExerciseStats(state.selectedExercise, filteredDates, state.chartType);
            if (!stats.labels.length) {
                chartEmpty.style.display = "block";
                destroyChart();
                return;
            }

            chartEmpty.style.display = "none";
            const ctx = document.getElementById("exerciseChart").getContext("2d");
            destroyChart();
            state.chart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: stats.labels,
                    datasets: [
                        {
                            label: stats.label,
                            data: stats.values,
                            borderColor: "#0ea5e9",
                            backgroundColor: "rgba(14, 165, 233, 0.2)",
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: "bottom" }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function addCatalogExercise(group, name) {
            const catalog = state.data.catalogByGroup[group];
            if (!catalog.includes(name)) {
                catalog.push(name);
                catalog.sort((a, b) => a.localeCompare(b, "ru"));
                state.data.catalogUpdatedAt[group] = new Date().toISOString();
                saveData();
                renderWorkout();
            }
        }

        function addCatalogFromPanel() {
            const input = catalogPanel.querySelector("[data-catalog-new]");
            if (!input) return;
            const name = input.value.trim();
            if (!name) return;
            addCatalogExercise(state.selectedCatalogGroup, name);
            state.selectedCatalogExercise[state.selectedCatalogGroup] = name;
            input.value = "";
            input.focus();
        }

        function deleteCatalog(group, name) {
            const catalog = state.data.catalogByGroup[group];
            state.data.catalogByGroup[group] = catalog.filter(item => item !== name);
            if (state.selectedCatalogExercise[group] === name) {
                state.selectedCatalogExercise[group] = state.data.catalogByGroup[group][0] || "";
            }
            state.data.catalogUpdatedAt[group] = new Date().toISOString();
            saveData();
            renderWorkout();
        }

        function renameCatalogPrompt(group, oldName) {
            const nextName = window.prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è:", oldName);
            if (!nextName) return;
            renameCatalog(group, oldName, nextName.trim());
        }

        function renameCatalog(group, oldName, newName) {
            if (!newName) return;
            const catalog = state.data.catalogByGroup[group];
            const exists = catalog.find(item => item.toLowerCase() === newName.toLowerCase());
            if (exists && exists !== oldName) return;
            const index = catalog.indexOf(oldName);
            if (index === -1) return;
            catalog[index] = newName;
            catalog.sort((a, b) => a.localeCompare(b, "ru"));
            if (state.selectedCatalogExercise[group] === oldName) {
                state.selectedCatalogExercise[group] = newName;
            }
            state.data.catalogUpdatedAt[group] = new Date().toISOString();

            Object.values(state.data.workoutsByDate).forEach(workout => {
                workout.entries.forEach(entry => {
                    if (entry.group === group && entry.name === oldName) {
                        entry.name = newName;
                    }
                });
            });

            saveData();
            renderWorkout();
            renderCharts();
        }

        function addEntryFromCatalog(group) {
            const select = catalogPanel.querySelector("[data-catalog-select]");
            if (!select) return;
            const name = decodeName(select.value || "");
            if (!name) return;
            addEntry(group, name);
        }

        function selectCatalogGroup(group) {
            state.selectedCatalogGroup = group;
            if (!state.selectedCatalogExercise[group]) {
                const first = (state.data.catalogByGroup[group] || [])[0] || "";
                state.selectedCatalogExercise[group] = first;
            }
            renderCatalogPanel();
        }

        function selectCatalogExercise(group, name) {
            state.selectedCatalogExercise[group] = name;
            renderCatalogPanel();
        }

        function renameSelectedExercise(group) {
            const selected = state.selectedCatalogExercise[group] || "";
            if (!selected) return;
            renameCatalogPrompt(group, selected);
        }

        function deleteSelectedExercise(group) {
            const selected = state.selectedCatalogExercise[group] || "";
            if (!selected) return;
            deleteCatalog(group, selected);
        }

        function showChartForExercise(name) {
            if (!name) return;
            state.selectedExercise = name;
            setActiveTab("charts");
            renderCharts();
        }

        function addEntry(group, name) {
            const workout = ensureWorkout(state.selectedDateKey);
            if (!workout.durationStart) {
                workout.durationStart = new Date().toISOString();
            }
            workout.entries.push({
                id: cryptoId(),
                group,
                name,
                sets: []
            });
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
        }

        function deleteEntry(entryId) {
            const workout = ensureWorkout(state.selectedDateKey);
            workout.entries = workout.entries.filter(entry => entry.id !== entryId);
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
            renderCharts();
        }

        function addSet(entryId, weight, reps, restMin) {
            const workout = ensureWorkout(state.selectedDateKey);
            const entry = workout.entries.find(item => item.id === entryId);
            if (!entry) return;
            const restSec = Math.max(0, restMin) * 60;
            entry.sets.push({
                id: cryptoId(),
                weight,
                reps,
                restSec,
                createdAt: new Date().toISOString()
            });
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
            renderCharts();
            if (restSec > 0) {
                startTimer(restSec);
            }
        }

        function incrementRest(entryId) {
            const form = entriesList.querySelector(`.set-form[data-entry-id="${entryId}"]`);
            if (!form) return;
            const input = form.querySelector("[name=restMin]");
            const current = parseInt(input.value, 10) || 0;
            input.value = current + 1;
            input.focus();
        }

        function addRepeatPlus(entryId) {
            const workout = ensureWorkout(state.selectedDateKey);
            const entry = workout.entries.find(item => item.id === entryId);
            if (!entry || !entry.sets.length) return;
            const lastSet = entry.sets[entry.sets.length - 1];
            const newSet = {
                id: cryptoId(),
                weight: lastSet.weight,
                reps: lastSet.reps + 1,
                restSec: lastSet.restSec || 0,
                createdAt: new Date().toISOString()
            };
            entry.sets.push(newSet);
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
            renderCharts();
            if (newSet.restSec > 0) {
                startTimer(newSet.restSec);
            }
        }

        function toggleManualInput(entryId) {
            const form = entriesList.querySelector(`.set-form[data-entry-id="${entryId}"]`);
            if (!form) return;
            const manualRow = form.querySelector(".manual-row");
            const toggleBtn = form.querySelector("[data-action=toggle-manual]");
            if (!manualRow || !toggleBtn) return;
            const isHidden = manualRow.classList.contains("hidden");
            manualRow.classList.toggle("hidden", !isHidden);
            toggleBtn.textContent = isHidden ? "–°–∫—Ä—ã—Ç—å –≤–≤–æ–¥" : "–†—É—á–Ω–æ–π –≤–≤–æ–¥";
            if (isHidden) {
                const input = manualRow.querySelector("[name=weightManual]");
                if (input) input.focus();
            }
        }

        function deleteSet(entryId, setId) {
            const workout = ensureWorkout(state.selectedDateKey);
            const entry = workout.entries.find(item => item.id === entryId);
            if (!entry) return;
            entry.sets = entry.sets.filter(set => set.id !== setId);
            if (state.editingSet && state.editingSet.setId === setId) {
                state.editingSet = null;
            }
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
            renderCharts();
        }

        function setEditingSet(entryId, setId) {
            state.editingSet = { entryId, setId };
            renderWorkout();
        }

        function clearEditingSet() {
            state.editingSet = null;
            renderWorkout();
        }

        function saveEditedSet(entryId, setId, button) {
            const row = button.closest(".set-row");
            if (!row) return;
            const weightInput = row.querySelector("[data-edit-weight]");
            const repsInput = row.querySelector("[data-edit-reps]");
            const weight = parseFloat(weightInput?.value);
            const reps = parseInt(repsInput?.value, 10);
            if (!Number.isFinite(weight) || !Number.isFinite(reps)) return;
            const workout = ensureWorkout(state.selectedDateKey);
            const entry = workout.entries.find(item => item.id === entryId);
            if (!entry) return;
            const set = entry.sets.find(item => item.id === setId);
            if (!set) return;
            set.weight = weight;
            set.reps = reps;
            workout.updatedAt = new Date().toISOString();
            state.editingSet = null;
            saveData();
            renderWorkout();
            renderCalendar();
            renderCharts();
        }

        function exportData() {
            const payload = {
                exportedAt: new Date().toISOString(),
                data: state.data
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `workout-data-${toDateKey(new Date())}.json`;
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
        }

        function initSupabase() {
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return;
            state.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            state.supabase.auth.getSession().then(({ data }) => {
                state.user = data.session?.user || null;
                updateAuthStatus();
                if (state.user) {
                    syncFromSupabase();
                }
            });
            state.supabase.auth.onAuthStateChange((_event, session) => {
                state.user = session?.user || null;
                updateAuthStatus();
                if (state.user) {
                    syncFromSupabase();
                }
            });
        }

        function updateAuthStatus(message) {
            if (authStatus) {
                authStatus.textContent = message || (state.user ? `–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞: ${state.user.email}` : "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞");
            }
            if (syncStatus) {
                const icon = state.user ? "‚úÖ" : "‚ö†Ô∏è";
                const text = message || (state.user ? "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞" : "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞");
                syncStatus.textContent = `${icon} ${text}`;
            }
            if (authPanel) {
                authPanel.style.display = state.user ? "none" : "grid";
            }
        }

        async function sendMagicLink() {
            if (!state.supabase) return;
            const email = authEmail.value.trim();
            if (!email) return;
            updateAuthStatus("–û—Ç–ø—Ä–∞–≤–ª—è—é —Å—Å—ã–ª–∫—É...");
            const { error } = await state.supabase.auth.signInWithOtp({
                email,
                options: { emailRedirectTo: window.location.href }
            });
            if (error) {
                updateAuthStatus("–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞");
                return;
            }
            updateAuthStatus("–°—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ—á—Ç—É.");
        }

        async function signInWithPassword() {
            if (!state.supabase) return;
            const email = authEmail.value.trim();
            const password = authPassword.value;
            if (!email || !password) return;
            updateAuthStatus("–í—Ö–æ–∂—É...");
            const { error } = await state.supabase.auth.signInWithPassword({ email, password });
            if (error) {
                updateAuthStatus("–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞");
                return;
            }
            updateAuthStatus();
        }

        async function signUpWithPassword() {
            if (!state.supabase) return;
            const email = authEmail.value.trim();
            const password = authPassword.value;
            if (!email || !password) return;
            updateAuthStatus("–°–æ–∑–¥–∞—é –∞–∫–∫–∞—É–Ω—Ç...");
            const { error } = await state.supabase.auth.signUp({ email, password });
            if (error) {
                updateAuthStatus("–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏");
                return;
            }
            updateAuthStatus("–ê–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω. –í–æ–π–¥–∏—Ç–µ.");
        }

        async function signOut() {
            if (!state.supabase) return;
            await state.supabase.auth.signOut();
            state.user = null;
            updateAuthStatus("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞");
        }

        let syncTimer = null;
        function scheduleSync() {
            if (!state.user || !state.supabase) return;
            if (syncTimer) clearTimeout(syncTimer);
            syncTimer = setTimeout(() => {
                syncToSupabase();
            }, 1200);
        }

        async function syncFromSupabase() {
            if (!state.user || state.syncing) return;
            state.syncing = true;
            updateAuthStatus("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è...");

            const { data: workoutRows, error: workoutError } = await state.supabase
                .from("workouts")
                .select("date_key, data, updated_at")
                .eq("user_id", state.user.id);

            const { data: catalogRows, error: catalogError } = await state.supabase
                .from("catalogs")
                .select("group, items, updated_at")
                .eq("user_id", state.user.id);

            if (workoutError || catalogError) {
                state.syncing = false;
                updateAuthStatus("–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏");
                return;
            }

            const remoteWorkouts = {};
            workoutRows.forEach(row => {
                remoteWorkouts[row.date_key] = row.data;
                state.remoteCache.workouts[row.date_key] = row.updated_at || row.data?.updatedAt || null;
            });

            const remoteCatalogs = {};
            catalogRows.forEach(row => {
                remoteCatalogs[row.group] = row.items || [];
                state.remoteCache.catalogs[row.group] = row.updated_at || null;
            });

            const merged = mergeWorkouts(state.data.workoutsByDate, remoteWorkouts);
            state.data.workoutsByDate = merged;

            GROUPS.forEach(group => {
                const localUpdated = state.data.catalogUpdatedAt[group];
                const remoteUpdated = state.remoteCache.catalogs[group];
                if (!remoteUpdated && localUpdated) {
                    return;
                }
                if (remoteUpdated && (!localUpdated || new Date(remoteUpdated) > new Date(localUpdated))) {
                    state.data.catalogByGroup[group] = remoteCatalogs[group] || [];
                    state.data.catalogUpdatedAt[group] = remoteUpdated;
                }
            });

            saveData(true);
            renderAll();
            state.syncing = false;
            updateAuthStatus();
        }

        async function syncToSupabase() {
            if (!state.user || state.syncing) return;
            state.syncing = true;
            updateAuthStatus("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è...");

            const workoutRows = [];
            Object.entries(state.data.workoutsByDate).forEach(([dateKey, workout]) => {
                const remoteUpdated = state.remoteCache.workouts[dateKey];
                if (!remoteUpdated || new Date(workout.updatedAt || 0) > new Date(remoteUpdated)) {
                    workoutRows.push({
                        user_id: state.user.id,
                        date_key: dateKey,
                        data: workout
                    });
                }
            });

            if (workoutRows.length) {
                const { error } = await state.supabase
                    .from("workouts")
                    .upsert(workoutRows.map(row => ({
                        ...row,
                        updated_at: row.data.updatedAt || new Date().toISOString()
                    })), { onConflict: "user_id,date_key" });
                if (!error) {
                    workoutRows.forEach(row => {
                        state.remoteCache.workouts[row.date_key] = row.data.updatedAt || new Date().toISOString();
                    });
                }
            }

            const catalogRows = [];
            GROUPS.forEach(group => {
                const localUpdated = state.data.catalogUpdatedAt[group];
                const remoteUpdated = state.remoteCache.catalogs[group];
                if (localUpdated && (!remoteUpdated || new Date(localUpdated) > new Date(remoteUpdated))) {
                    catalogRows.push({
                        user_id: state.user.id,
                        group,
                        items: state.data.catalogByGroup[group]
                    });
                }
            });

            if (catalogRows.length) {
                const { error } = await state.supabase
                    .from("catalogs")
                    .upsert(catalogRows.map(row => ({
                        ...row,
                        updated_at: state.data.catalogUpdatedAt[row.group] || new Date().toISOString()
                    })), { onConflict: "user_id,group" });
                if (!error) {
                    catalogRows.forEach(row => {
                        state.remoteCache.catalogs[row.group] = state.data.catalogUpdatedAt[row.group] || new Date().toISOString();
                    });
                }
            }

            state.syncing = false;
            updateAuthStatus();
        }

        function mergeWorkouts(localWorkouts, remoteWorkouts) {
            const merged = { ...localWorkouts };
            Object.entries(remoteWorkouts).forEach(([dateKey, remoteWorkout]) => {
                const localWorkout = localWorkouts[dateKey];
                if (!localWorkout) {
                    merged[dateKey] = remoteWorkout;
                    return;
                }
                const localTime = new Date(localWorkout.updatedAt || 0).getTime();
                const remoteTime = new Date(remoteWorkout.updatedAt || 0).getTime();
                merged[dateKey] = remoteTime > localTime ? remoteWorkout : localWorkout;
            });
            return merged;
        }

        function buildWeightOptions() {
            const values = [];
            for (let value = 0; value <= 300; value += 2.5) {
                const rounded = Math.round(value * 10) / 10;
                const label = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
                values.push(`<option value="${label}">${label} –∫–≥</option>`);
            }
            return values.join("");
        }

        function buildRepOptions() {
            const values = [];
            for (let value = 1; value <= 30; value += 1) {
                values.push(`<option value="${value}">${value} –ø–æ–≤—Ç–æ—Ä–æ–≤</option>`);
            }
            return values.join("");
        }

        function ensureWorkout(dateKey) {
            if (!state.data.workoutsByDate[dateKey]) {
                state.data.workoutsByDate[dateKey] = {
                    date: dateKey,
                    entries: [],
                    moodBefore: 0,
                    moodAfter: 0,
                    durationStart: null,
                    durationSeconds: 0,
                    finishedAt: null,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                saveData();
            }
            return state.data.workoutsByDate[dateKey];
        }

        function workoutHasData(dateKey) {
            const workout = state.data.workoutsByDate[dateKey];
            if (!workout) return false;
            return workout.entries.some(entry => entry.sets.length);
        }

        function calculateTonnage(dateKey) {
            const workout = state.data.workoutsByDate[dateKey];
            if (!workout) return 0;
            let total = 0;
            workout.entries.forEach(entry => {
                entry.sets.forEach(set => {
                    total += set.weight * set.reps;
                });
            });
            return total;
        }

        function changeMonth(direction) {
            state.currentMonth = new Date(state.currentMonth.getFullYear(), state.currentMonth.getMonth() + direction, 1);
            renderCalendar();
        }

        function startTimer(forcedSeconds) {
            if (forcedSeconds !== undefined) {
                state.restTimer.total = forcedSeconds;
                state.restTimer.remaining = forcedSeconds;
            } else if (state.restTimer.remaining === 0 && state.restTimer.total > 0) {
                state.restTimer.remaining = state.restTimer.total;
            }
            if (state.restTimer.remaining <= 0) return;
            clearInterval(state.restTimer.intervalId);
            state.restTimer.running = true;
            timerStatus.textContent = "–û—Ç–¥—ã—Ö –∏–¥–µ—Ç";
            state.restTimer.intervalId = setInterval(() => {
                state.restTimer.remaining -= 1;
                if (state.restTimer.remaining <= 0) {
                    state.restTimer.remaining = 0;
                    pauseTimer();
                    timerStatus.textContent = "–û—Ç–¥—ã—Ö –∑–∞–≤–µ—Ä—à–µ–Ω";
                }
                renderTimer();
            }, 1000);
            renderTimer();
        }

        function pauseTimer() {
            clearInterval(state.restTimer.intervalId);
            state.restTimer.intervalId = null;
            state.restTimer.running = false;
            if (state.restTimer.remaining > 0) {
                timerStatus.textContent = "–ü–∞—É–∑–∞";
            }
            renderTimer();
        }

        function resetTimer() {
            clearInterval(state.restTimer.intervalId);
            state.restTimer.intervalId = null;
            state.restTimer.remaining = state.restTimer.total || 0;
            state.restTimer.running = false;
            timerStatus.textContent = "–ì–æ—Ç–æ–≤ –∫ —Å—Ç–∞—Ä—Ç—É";
            renderTimer();
        }

        function renderTimer() {
            timerDisplay.textContent = formatDuration(state.restTimer.remaining);
            const percent = state.restTimer.total ? (state.restTimer.remaining / state.restTimer.total) * 100 : 0;
            timerBar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            const expired = state.restTimer.total > 0 && state.restTimer.remaining === 0;
            timerBar.classList.toggle("expired", expired);
        }

        function renderDuration() {
            const workout = ensureWorkout(state.selectedDateKey);
            if (durationIntervalId) {
                clearInterval(durationIntervalId);
                durationIntervalId = null;
            }
            durationValue.textContent = formatDurationHMS(getWorkoutDurationSeconds(workout));
            if (workout.durationStart) {
                durationIntervalId = setInterval(() => {
                    durationValue.textContent = formatDurationHMS(getWorkoutDurationSeconds(workout));
                }, 1000);
            }
        }

        function finishWorkout() {
            const workout = ensureWorkout(state.selectedDateKey);
            if (workout.finishedAt) return;
            workout.durationSeconds = getWorkoutDurationSeconds(workout);
            workout.durationStart = null;
            workout.finishedAt = new Date().toISOString();
            workout.updatedAt = new Date().toISOString();
            saveData();
            renderWorkout();
            renderCalendar();
        }

        function collectExerciseNames() {
            const names = new Set();
            Object.values(state.data.workoutsByDate).forEach(workout => {
                workout.entries.forEach(entry => {
                    if (entry.sets.length) names.add(entry.name);
                });
            });
            return Array.from(names).sort((a, b) => a.localeCompare(b, "ru"));
        }

        function buildExerciseStats(name, dates, type) {
            const labels = [];
            const values = [];

            dates.forEach(dateKey => {
                const workout = state.data.workoutsByDate[dateKey];
                const metric = computeMetricForWorkout(workout, name, type);
                if (metric !== null) {
                    labels.push(formatShortDate(dateKey));
                    values.push(metric);
                }
            });

            return { labels, values, label: chartLabel(type) };
        }

        function computeMetricForWorkout(workout, name, type) {
            let sets = [];
            workout.entries.forEach(entry => {
                if (entry.name !== name) return;
                sets = sets.concat(entry.sets || []);
            });
            if (!sets.length) return null;

            if (type === "max") {
                return Math.max(...sets.map(set => set.weight));
            }
            if (type === "tonnage") {
                return sets.reduce((sum, set) => sum + set.weight * set.reps, 0);
            }
            if (type === "avgWeight") {
                const total = sets.reduce((sum, set) => sum + set.weight, 0);
                return Number((total / sets.length).toFixed(1));
            }
            if (type === "avgReps") {
                const total = sets.reduce((sum, set) => sum + set.reps, 0);
                return Number((total / sets.length).toFixed(1));
            }
            if (type === "sets") {
                return sets.length;
            }
            if (type === "oneRm") {
                const best = sets.reduce((max, set) => {
                    const estimate = set.weight * (1 + set.reps / 30);
                    return Math.max(max, estimate);
                }, 0);
                return Number(best.toFixed(1));
            }
            if (type === "topSet") {
                const best = sets.reduce((max, set) => {
                    const value = set.weight * set.reps;
                    return Math.max(max, value);
                }, 0);
                return Number(best.toFixed(1));
            }
            return null;
        }

        function chartLabel(type) {
            const map = {
                max: "–ú–∞–∫—Å. –≤–µ—Å, –∫–≥",
                tonnage: "–¢–æ–Ω–Ω–∞–∂, –∫–≥",
                avgWeight: "–°—Ä–µ–¥–Ω–∏–π –≤–µ—Å, –∫–≥",
                avgReps: "–°—Ä–µ–¥–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—ã",
                sets: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥—Ö–æ–¥–æ–≤",
                oneRm: "1RM (Epley), –∫–≥",
                topSet: "–¢–æ–ø-—Å–µ—Ç (–∫–≥√ó–ø–æ–≤—Ç–æ—Ä—ã)"
            };
            return map[type] || "–ó–Ω–∞—á–µ–Ω–∏–µ";
        }

        function findPreviousSet(name, currentDateKey) {
            const dates = Object.keys(state.data.workoutsByDate).sort();
            const currentIndex = dates.indexOf(currentDateKey);
            const endIndex = currentIndex === -1 ? dates.length : currentIndex;
            for (let i = endIndex - 1; i >= 0; i -= 1) {
                const dateKey = dates[i];
                const workout = state.data.workoutsByDate[dateKey];
                if (!workout || !workout.entries) continue;
                for (let j = workout.entries.length - 1; j >= 0; j -= 1) {
                    const entry = workout.entries[j];
                    if (entry.name !== name || !entry.sets.length) continue;
                    return entry.sets[entry.sets.length - 1];
                }
            }
            return null;
        }

        function destroyChart() {
            if (state.chart) {
                state.chart.destroy();
                state.chart = null;
            }
        }

        function loadData() {
            const raw = localStorage.getItem(STORAGE_KEY);
            let data = raw ? JSON.parse(raw) : { workoutsByDate: {}, catalogByGroup: {} };
            if (!raw) {
                data = migrateFromPreviousStorage();
            }
            data.catalogByGroup = data.catalogByGroup || {};
            data.catalogUpdatedAt = data.catalogUpdatedAt || {};
            GROUPS.forEach(group => {
                if (!data.catalogByGroup[group]) data.catalogByGroup[group] = [];
                if (!data.catalogUpdatedAt[group]) data.catalogUpdatedAt[group] = null;
            });
            applyDefaultCatalog(data);
            Object.values(data.workoutsByDate || {}).forEach(workout => {
                if (workout.moodBefore === undefined) workout.moodBefore = 0;
                if (workout.moodAfter === undefined) workout.moodAfter = 0;
                if (workout.durationStart === undefined) workout.durationStart = null;
                if (workout.durationSeconds === undefined) workout.durationSeconds = 0;
                if (workout.finishedAt === undefined) workout.finishedAt = null;
                if (workout.updatedAt === undefined) workout.updatedAt = workout.createdAt || new Date().toISOString();
            });
            return data;
        }

        function applyDefaultCatalog(data) {
            const isEmpty = GROUPS.every(group => (data.catalogByGroup[group] || []).length === 0);
            if (!isEmpty) return;
            const now = new Date().toISOString();
            GROUPS.forEach(group => {
                data.catalogByGroup[group] = [...(DEFAULT_CATALOG[group] || [])];
                data.catalogUpdatedAt[group] = now;
            });
        }

        function saveData(skipSync) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state.data));
            if (!skipSync) {
                scheduleSync();
            }
        }

        function migrateFromPreviousStorage() {
            const migrated = { workoutsByDate: {}, catalogByGroup: {} };
            migrated.catalogUpdatedAt = {};
            GROUPS.forEach(group => { migrated.catalogByGroup[group] = []; });

            const legacyV2 = localStorage.getItem("workoutDataV2");
            if (legacyV2) {
                try {
                    const parsed = JSON.parse(legacyV2);
                    Object.entries(parsed.workoutsByDate || {}).forEach(([dateKey, workout]) => {
                        migrated.workoutsByDate[dateKey] = {
                            date: dateKey,
                            entries: [],
                            moodBefore: workout.moodBefore || 0,
                            moodAfter: workout.moodAfter || 0,
                            durationStart: workout.durationStart || null,
                            durationSeconds: workout.durationSeconds || 0,
                            finishedAt: workout.finishedAt || null,
                            createdAt: workout.createdAt || new Date().toISOString(),
                            updatedAt: workout.updatedAt || new Date().toISOString()
                        };
                        GROUPS.forEach(group => {
                            (workout.groups?.[group] || []).forEach(ex => {
                                migrated.workoutsByDate[dateKey].entries.push({
                                    id: cryptoId(),
                                    group,
                                    name: ex.name,
                                    sets: (ex.sets || []).map(set => ({
                                        id: cryptoId(),
                                        weight: set.weight,
                                        reps: set.reps,
                                        restSec: set.restSec || 0,
                                        createdAt: set.createdAt || new Date().toISOString()
                                    }))
                                });
                                if (ex.name && !migrated.catalogByGroup[group].includes(ex.name)) {
                                    migrated.catalogByGroup[group].push(ex.name);
                                }
                            });
                        });
                    });
                    GROUPS.forEach(group => {
                        migrated.catalogByGroup[group].sort((a, b) => a.localeCompare(b, "ru"));
                        migrated.catalogUpdatedAt[group] = new Date().toISOString();
                    });
                    return migrated;
                } catch (error) {
                    return migrated;
                }
            }

            const legacyCurrent = localStorage.getItem("currentWorkout");
            const legacyAll = localStorage.getItem("allWorkouts");
            if (!legacyCurrent && !legacyAll) return migrated;

            const legacyWorkouts = [];
            if (legacyCurrent) legacyWorkouts.push(JSON.parse(legacyCurrent));
            if (legacyAll) legacyWorkouts.push(...JSON.parse(legacyAll));

            legacyWorkouts.forEach(workout => {
                const dateKey = legacyDateToKey(workout.date || workout.completedAt || new Date());
                if (!migrated.workoutsByDate[dateKey]) {
                    migrated.workoutsByDate[dateKey] = {
                        date: dateKey,
                        entries: [],
                        moodBefore: 0,
                        moodAfter: 0,
                        durationStart: null,
                        durationSeconds: 0,
                        finishedAt: null,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                }
                (workout.exercises || []).forEach(ex => {
                    const entry = {
                        id: cryptoId(),
                        group: "–ë–µ–∑ –≥—Ä—É–ø–ø—ã",
                        name: ex.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è",
                        sets: []
                    };
                    const setCount = ex.sets || 1;
                    for (let i = 0; i < setCount; i += 1) {
                        entry.sets.push({
                            id: cryptoId(),
                            weight: Number(ex.weight) || 0,
                            reps: Number(ex.reps) || 0,
                            restSec: 0,
                            createdAt: new Date().toISOString()
                        });
                    }
                    migrated.workoutsByDate[dateKey].entries.push(entry);
                });
            });

            GROUPS.forEach(group => {
                migrated.catalogUpdatedAt[group] = null;
            });

            return migrated;
        }

        function toDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        }

        function formatDate(dateKey) {
            const [year, month, day] = dateKey.split("-").map(Number);
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString("ru-RU", { weekday: "long", day: "numeric", month: "long", year: "numeric" });
        }

        function formatShortDate(dateKey) {
            const [year, month, day] = dateKey.split("-").map(Number);
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString("ru-RU", { day: "2-digit", month: "2-digit" });
        }

        function getFilteredDates(dates) {
            if (state.period === "all") return dates;
            if (state.period === "custom") {
                const from = state.customFrom || fromDate.value;
                const to = state.customTo || toDate.value;
                if (!from && !to) return dates;
                const fromTime = from ? parseDateKey(from).getTime() : null;
                const toTime = to ? parseDateKey(to).getTime() : null;
                return dates.filter(dateKey => {
                    const time = parseDateKey(dateKey).getTime();
                    if (fromTime && time < fromTime) return false;
                    if (toTime && time > toTime) return false;
                    return true;
                });
            }
            const days = parseInt(state.period, 10);
            if (!Number.isFinite(days)) return dates;
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (days - 1));
            const startTime = start.getTime();
            return dates.filter(dateKey => parseDateKey(dateKey).getTime() >= startTime);
        }

        function formatDuration(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        }

        function formatDurationHMS(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        }

        function getWorkoutDurationSeconds(workout) {
            const base = Number(workout.durationSeconds) || 0;
            if (!workout.durationStart) return base;
            const start = new Date(workout.durationStart).getTime();
            if (Number.isNaN(start)) return base;
            const diff = Math.floor((Date.now() - start) / 1000);
            return Math.max(0, base + diff);
        }

        function formatNumber(value) {
            return Number(value || 0).toLocaleString("ru-RU");
        }

        function legacyDateToKey(value) {
            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) return toDateKey(new Date());
            return toDateKey(parsed);
        }

        function parseDateKey(value) {
            const [year, month, day] = String(value).split("-").map(Number);
            return new Date(year, (month || 1) - 1, day || 1);
        }

        function cryptoId() {
            if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
            return `id-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
        }

        function capitalizeFirst(text) {
            if (!text) return text;
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function encodeName(name) {
            return encodeURIComponent(name);
        }

        function decodeName(value) {
            return decodeURIComponent(value || "");
        }

        function escapeHtml(text) {
            return String(text)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/\"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>
